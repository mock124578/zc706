#include "qpsk_demod.h"
#include <stdio.h>

// 初始化QPSK解调器
void qpsk_demod_init(qpsk_demod_t* demod) {
    if(demod == NULL) return;

    // 设置默认相位配置（Gray编码）
    demod->phase_45_deg = 45.0f;
    demod->phase_135_deg = 135.0f;
    demod->phase_225_deg = 225.0f;
    demod->phase_315_deg = 315.0f;

    // 重置状态
    demod->symbols_processed = 0;
    demod->bit_errors = 0;
}

// 单个符号解调
void qpsk_demod_symbol(qpsk_demod_t* demod, complex_float_t symbol, uint8_t* bit1, uint8_t* bit2) {
    if(demod == NULL || bit1 == NULL || bit2 == NULL) return;

    // 计算相位角（度）
    float phase = atan2f(symbol.imag, symbol.real) * 180.0f / M_PI;
    if(phase < 0) phase += 360.0f;

    // 计算与各个理想相位的距离
    float diff_45 = fabsf(phase - demod->phase_45_deg);
    float diff_135 = fabsf(phase - demod->phase_135_deg);
    float diff_225 = fabsf(phase - demod->phase_225_deg);
    float diff_315 = fabsf(phase - demod->phase_315_deg);

    // 最近邻判决
    if(diff_45 <= diff_135 && diff_45 <= diff_225 && diff_45 <= diff_315) {
        *bit1 = 1; *bit2 = 1;  // "11"
    } else if(diff_135 <= diff_45 && diff_135 <= diff_225 && diff_135 <= diff_315) {
        *bit1 = 0; *bit2 = 1;  // "01"
    } else if(diff_225 <= diff_45 && diff_225 <= diff_135 && diff_225 <= diff_315) {
        *bit1 = 0; *bit2 = 0;  // "00"
    } else {
        *bit1 = 1; *bit2 = 0;  // "10"
    }

    demod->symbols_processed++;
}

// 批量解调
void qpsk_demod_batch(qpsk_demod_t* demod, complex_float_t* symbols, uint8_t* bits_output, uint32_t num_symbols) {
    if(demod == NULL || symbols == NULL || bits_output == NULL) return;

    for(uint32_t i = 0; i < num_symbols; i++) {
        uint8_t bit1, bit2;
        qpsk_demod_symbol(demod, symbols[i], &bit1, &bit2);

        // 将2个比特打包成一个字节（高6位为0，低2位为比特）
        bits_output[i] = (bit1 << 1) | bit2;
    }
}

// 比特到字符串转换
const char* qpsk_bits_to_string(uint8_t bit1, uint8_t bit2) {
    if(bit1 == 1 && bit2 == 1) return "11";
    if(bit1 == 0 && bit2 == 1) return "01";
    if(bit1 == 0 && bit2 == 0) return "00";
    if(bit1 == 1 && bit2 == 0) return "10";
    return "??";
}

// 获取误码率
float qpsk_get_ber(qpsk_demod_t* demod) {
    if(demod == NULL || demod->symbols_processed == 0) return 0.0f;
    return (float)demod->bit_errors / (demod->symbols_processed * 2); // 每个符号2个比特
}
